# Claude Code Custom Command Prompts

This document contains the prompt templates to recreate the custom slash commands for Linear integration and review functionality.

## /execute-linear Command Prompt

```
Execute Linear Issue $ARGUMENTS with full implementation using Unity MCP tools where possible.

Follow these steps:
1. Get the issue details from Linear using MCP
2. Create a todo list to track implementation progress
3. Implement the required functionality using Unity MCP tools for direct Unity integration
4. Test the implementation thoroughly
5. Update the Linear issue status to "In Review" and add a completion comment with implementation summary
6. Provide a concise summary of what was accomplished

Use Unity MCP tools for:
- Creating/managing scripts with mcp__UnityMCP__manage_script
- Creating/managing GameObjects with mcp__UnityMCP__manage_gameobject
- Managing assets with mcp__UnityMCP__manage_asset
- Reading Unity console with mcp__UnityMCP__read_console
- Managing editor state with mcp__UnityMCP__manage_editor

Ensure all Unity C# code follows best practices, includes proper documentation, and integrates seamlessly with the ColorMatch game architecture.
```

## /review-task Command Prompt

```
# Review Task Implementation

Performs a comprehensive review of a single task implementation, validating code quality, scope adherence, and integration readiness.

Task ID: $ARGUMENTS

## Review Process

### 🔍 Single Task Analysis
- **Code Quality**: Validate implementation against Unity best practices
- **Scope Adherence**: Ensure implementation matches original task specification
- **Documentation Review**: Check inline comments and XML documentation
- **Unity Integration**: Validate proper MonoBehaviour patterns and lifecycle usage

### 🔗 Integration Readiness
- **Dependency Check**: Validate all required dependencies are properly referenced
- **Interface Compliance**: Ensure proper interface implementations
- **Component Integration**: Validate GameObject and component setup
- **Event System**: Review event subscriptions and lifecycle management

### 📊 Quality Metrics
- **Complexity Analysis**: Identify overly complex methods or classes
- **Performance Review**: Flag potential performance concerns
- **Memory Management**: Review object lifecycle and cleanup
- **Error Handling**: Validate exception handling and graceful failures

## Linear Integration

Create a Linear sub-issue for task review with:
- **Title**: "🔍 Task Review: [Task Name] - Quality Assessment"
- **Parent Issue**: Link to the reviewed task issue
- **Labels**: "task-review", "quality-gate", + severity labels
- **Status**: "In Review"

## Output Format

# 🔍 Task Quality Review: [Task Name]

## Task Overview
**Task ID:** [ID]  
**Implementation Status:** [Complete/Partial]  
**Review Score:** [Score]/100  

## Code Quality Assessment
### ✅ Quality Standards Met
- [List of passed validations]

### ⚠️ Improvements Recommended  
- [List of suggestions with priority]

### ❌ Issues Requiring Attention
- [Critical issues that must be addressed]

## Scope Validation
**Requirements Met:** [X]/[Total]  
**Scope Adherence:** [Percentage]  
**Feature Creep Detected:** [Yes/No]  

## Integration Readiness
- **Dependencies:** [Status]
- **Interface Compliance:** [Status] 
- **Component Setup:** [Status]

## Next Steps
[Actionable recommendations for task completion]

---
🤖 Generated by automated task review  
📅 Review Date: [Timestamp]  
🔗 Parent Task: [Link to task issue]
```

## /review-feature Command Prompt

```
# Review Feature Implementation

Performs a comprehensive review of all tasks completed for a specific feature, validating logic, integration, scope adherence, and feature completion.

Feature ID: $ARGUMENTS

## Review Process

1. **Feature Discovery**: Identify all tasks belonging to the specified feature
2. **Task Sequence Analysis**: Review tasks in chronological order within the feature
3. **File Analysis**: Scan all files modified across all feature tasks
4. **Cross-Task Integration**: Validate relationships between task implementations
5. **Feature Completion Check**: Ensure all feature requirements are satisfied
6. **Specification Comparison**: Compare final implementation against original feature requirements
7. **Quality Assessment**: Apply Unity coding standards and best practices across all tasks
8. **Integration Testing**: Suggest feature-level integration test scenarios
9. **Documentation Review**: Evaluate comment quality and feature documentation completeness

### 🔍 Code Quality Review
- **Logic Validation**: Ensure all implemented logic is sound and follows Unity best practices
- **Integration Check**: Validate that components properly integrate with each other
- **Dependency Analysis**: Confirm all required dependencies are present and properly referenced
- **Error Handling**: Review exception handling and graceful failure scenarios

### 📋 Scope Adherence
- **Requirement Alignment**: Check implementation against original task specifications
- **Feature Creep Detection**: Identify any functionality that wasn't explicitly requested
- **Missing Elements**: Highlight any required elements that might have been overlooked
- **Overengineering Check**: Flag unnecessarily complex implementations

### 🔗 Integration Validation
- **Component References**: Ensure all serialized fields and component references are properly assigned
- **Event System**: Validate event subscriptions and unsubscriptions are balanced
- **Singleton Pattern**: Check singleton implementations for thread safety and proper cleanup
- **State Management**: Review state transitions and consistency

### 📝 Documentation & Comments
- **Code Comments**: Review inline documentation quality and completeness
- **XML Documentation**: Validate public API documentation coverage
- **README Updates**: Check if project documentation reflects new features
- **Comment Accuracy**: Ensure comments match actual implementation

### 🧪 Testing & Validation
- **Runtime Testing**: Review any test implementations or validation scripts
- **Edge Cases**: Identify potential edge cases that may not be handled
- **Performance Impact**: Highlight potential performance concerns
- **Memory Management**: Review object lifecycle and cleanup

## Linear Integration

Create a Linear sub-issue with:
- **Title**: "🔍 Review: [Feature Name] - Quality Assessment"
- **Parent Issue**: Automatically linked to the reviewed feature issue
- **Labels**: "review", "quality-gate", severity level ("critical", "warning", "passed")
- **Status**: "In Review" (awaiting action on findings)

## Output Format

# 🔍 Quality Review: [Feature Name]

## Executive Summary
**Review Score:** [Score]/100  
**Feature Status:** [Complete/Needs Action]  
**Critical Issues:** [Count]  
**Recommendations:** [Count]  

## Review Findings

### ✅ Passed Quality Checks
- [List of passed validations]

### ⚠️ Warnings & Improvements
- [List of warnings with recommended actions]

### ❌ Critical Issues
- [List of critical issues requiring immediate attention]

## Integration Analysis
[Details of cross-task/cross-system integration validation]

## Recommendations
[Prioritized list of recommendations for improvement]

## Files Reviewed
[List of files with links to specific line numbers where relevant]

---
🤖 Generated by automated review system  
📅 Review Date: [Timestamp]  
🔗 Parent Issue: [Link to reviewed feature]
```

## /review-epic Command Prompt

```
# Review Epic Implementation

Performs a comprehensive review of an entire epic implementation, validating all features, cross-feature integration, and epic completion against requirements.

Epic ID: $ARGUMENTS

## What This Command Does

### 🎯 Epic-Level Analysis
- **Feature Completeness**: Validate all epic features are implemented and integrated
- **Requirements Traceability**: Ensure all epic requirements are satisfied
- **Architecture Coherence**: Review overall system design and consistency
- **Epic Scope Validation**: Confirm implementation stays within epic boundaries

### 🏗️ Cross-Feature Integration
- **System Cohesion**: Validate how features work together as a unified system
- **Data Flow Analysis**: Review information flow between features
- **Event System Integration**: Validate cross-feature event communication
- **Dependency Management**: Ensure proper feature dependency resolution

### 📊 Epic Quality Metrics
- **Overall Code Quality**: Aggregated quality score across all epic features
- **Architecture Compliance**: Validate adherence to architectural patterns
- **Performance Impact**: Assess epic's impact on system performance
- **Technical Debt**: Identify accumulated technical debt across features

### 🔍 Completeness Validation
- **Feature Coverage**: Ensure all planned features are implemented
- **Integration Testing**: Validate end-to-end epic functionality
- **User Story Fulfillment**: Confirm all user stories are satisfied
- **Acceptance Criteria**: Validate all epic acceptance criteria are met

## Linear Integration

Create a Linear sub-issue with:
- **Title**: "🔍 Epic Review: [Epic Name] - Comprehensive Quality Assessment"
- **Parent Issue**: Link to the reviewed epic issue
- **Labels**: "epic-review", "quality-gate", "architecture", + severity labels
- **Status**: "In Review"

## Output Format

# 🔍 Epic Quality Review: [Epic Name]

## Epic Overview
**Epic ID:** [ID]  
**Features Included:** [Count]  
**Tasks Completed:** [Count]  
**Overall Score:** [Score]/100  
**Completion Status:** [Complete/Partial/Blocked]

## Executive Summary
[High-level assessment of epic implementation quality and completeness]

## Feature Analysis
### Feature Breakdown
- **[Feature 1]:** [Status] - [Score]/100
- **[Feature 2]:** [Status] - [Score]/100  
- **[Feature N]:** [Status] - [Score]/100

### Cross-Feature Integration
**Integration Score:** [Score]/100  
**Critical Integration Issues:** [Count]  
**Integration Recommendations:** [Count]

## Architecture Assessment
### System Design Quality
- **Design Patterns:** [Assessment]
- **SOLID Principles:** [Compliance Score]
- **Unity Best Practices:** [Score]/100
- **Code Organization:** [Assessment]

### Technical Architecture
- **Component Design:** [Status]
- **Event System:** [Status]
- **Dependency Management:** [Status]
- **Performance Considerations:** [Status]

## Quality Summary
### ✅ Epic Strengths
- [List of well-implemented aspects]

### ⚠️ Areas for Improvement  
- [List of warnings and suggestions]

### ❌ Critical Issues
- [Critical issues requiring immediate attention]

## Recommendations
### Immediate Actions Required
1. [Priority 1 recommendations]
2. [Priority 1 recommendations]

### Future Enhancements
1. [Nice-to-have improvements]
2. [Future considerations]

## Performance Analysis
**Memory Impact:** [Assessment]  
**Runtime Performance:** [Assessment]  
**Scalability Concerns:** [List]  

## Completeness Check
- **User Stories:** [X]/[Total] Complete
- **Acceptance Criteria:** [X]/[Total] Met
- **Technical Requirements:** [X]/[Total] Satisfied
- **Integration Requirements:** [X]/[Total] Complete

## Next Epic Readiness
**Blocking Issues:** [Count]  
**Dependencies for Next Epic:** [List]  
**Recommendations for Next Phase:** [List]

---
🤖 Generated by automated epic review system  
📅 Review Date: [Timestamp]  
🔗 Parent Epic: [Link to epic issue]
```

## Usage Instructions

To recreate these custom commands in any project:

1. Create a `.claude/commands/` directory in your project root
2. Create markdown files for each command:
   - `execute-linear.md` - Copy the execute-linear prompt
   - `review-task.md` - Copy the review-task prompt
   - `review-feature.md` - Copy the review-feature prompt
   - `review-epic.md` - Copy the review-epic prompt

3. The commands will be available as slash commands when using Claude Code in that project

## Key Features

These commands provide:
- **Automated Linear Integration**: Automatic issue creation and updates
- **Comprehensive Code Review**: Multi-level review from task to epic
- **Unity-Specific Validation**: Unity best practices and patterns
- **Quality Metrics**: Quantitative scoring and assessment
- **Actionable Feedback**: Specific recommendations for improvement
- **Progress Tracking**: Integration with todo lists and status updates

## Required MCP Tools

These commands rely on:
- `mcp__linear-server__*` tools for Linear integration
- `mcp__UnityMCP__*` tools for Unity operations
- Standard Claude Code tools for file operations and analysis